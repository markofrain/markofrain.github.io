<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Notes
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/main.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover4.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Notes</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-Java/openOffce和jacob方式转换office为pdf文件" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/01/02/Java/openOffce%E5%92%8Cjacob%E6%96%B9%E5%BC%8F%E8%BD%AC%E6%8D%A2office%E4%B8%BApdf%E6%96%87%E4%BB%B6/"
    >openOffce和jacob方式转换office为pdf文件</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/01/02/Java/openOffce%E5%92%8Cjacob%E6%96%B9%E5%BC%8F%E8%BD%AC%E6%8D%A2office%E4%B8%BApdf%E6%96%87%E4%BB%B6/" class="article-date">
  <time datetime="2020-01-02T07:34:05.000Z" itemprop="datePublished">2020-01-02</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/">项目问题</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="OpenOffice-转换"><a href="#OpenOffice-转换" class="headerlink" title="OpenOffice 转换"></a>OpenOffice 转换</h2><p>首先需要到apache openoffice下载包并安装<a target="_blank" rel="noopener" href="http://www.openoffice.org/download/index.html">http://www.openoffice.org/download/index.html</a></p>
<p>windows默认会安装到c盘program file(x86)中的openoffice4中，可以把这个文件文件夹拷贝到任意位置。</p>
<p>要想使用转换首先需要jar包,他需要jodconverter的jar包，这包可能在maven中央仓库没有。详细的转换代码如下</p>
<pre><code>@Component
public class OfficeConverterUtils &#123;

    private Logger logger = LoggerFactory.getLogger(OfficeConverterUtils.class);

    @Value(&quot;$&#123;openoffice.path&#125;&quot;)
    private  String openOfficePath;

    public void WordToPDF(String startFile, String overFile) &#123;
        if (StringUtils.isBlank(openOfficePath))&#123;
            return;
        &#125;

        // 源文件目录
        File inputFile = new File(startFile);
        if (!inputFile.exists()) &#123;
            System.out.println(&quot;源文件不存在！&quot;);
            return;
        &#125;

        // 输出文件目录
        File outputFile = new File(overFile);
        if (!outputFile.getParentFile().exists()) &#123;
            outputFile.getParentFile().exists();
        &#125;
        OpenOfficeConnection connection = null;
        Process p = null;
        try &#123;

            // 调用openoffice服务线程
            /** 我把openOffice下载到了 C:/Program Files (x86)/下  ,下面的写法自己修改编辑就可以**/
            String command = openOfficePath + &quot; -headless -accept=\&quot;socket,host=127.0.0.1,port=8100;urp;\&quot;&quot;;
            try &#123;
                p = Runtime.getRuntime().exec(command);
            &#125;catch (Exception e)&#123;
                logger.error(&quot;服务无法启动或已经启动,请确认文件是否转换成功&quot;);
            &#125;
            // 连接openoffice服务
            connection = new SocketOpenOfficeConnection(&quot;127.0.0.1&quot;, 8100);
            connection.connect();

            // 转换
            DocumentConverter converter = new OpenOfficeDocumentConverter(connection);
            converter.convert(inputFile, outputFile);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            logger.error(&quot;转换PDF出现异常&quot;);
            logger.error(&quot;切换使用jocob方式转换&quot;);
            if (startFile.lastIndexOf(&quot;.docx&quot;)!=-1)&#123;
                JocobUtil.word2Pdf(startFile, overFile);
            &#125;else if(startFile.lastIndexOf(&quot;.doc&quot;)!=-1)&#123;
                JocobUtil.word2Pdf(startFile, overFile);
            &#125;else if(startFile.lastIndexOf(&quot;.xlsx&quot;)!=-1)&#123;
                JocobUtil.excel2Pdf(startFile, overFile);
            &#125;else if(startFile.lastIndexOf(&quot;.xls&quot;)!=-1)&#123;
                JocobUtil.excel2Pdf(startFile, overFile);
            &#125;
        &#125; finally &#123;
            // 关闭连接
            if (connection != null &amp;&amp; connection.isConnected()) &#123;
                connection.disconnect();
            &#125;
            // 关闭进程
            if (p != null &amp;&amp; p.isAlive()) &#123;
                p.destroy();
            &#125;
        &#125;

    &#125;

    public static void main(String[] args) &#123;
        //openOfficePath = &quot;D:/soft/OpenOffice4/program/soffice.exe&quot;;
        String start = &quot;C:\\Users\\lics\\Desktop\\abc.docx&quot;;
        String over = &quot;C:\\Users\\lics\\Desktop\\abc.pdf&quot;;

            new OfficeConverterUtils().WordToPDF(start, over);
    &#125;


&#125;</code></pre><p>以上是通过代码的方式启动服务，操作完成后会关闭服务。</p>
<p>还有通过cmd直接启动服务的。</p>
<pre><code>soffice -headless -accept=&quot;socket,host=127.0.0.1,port=8100;urp;&quot; -nofirststartwizard</code></pre><p>以上中，在C:\Program Files (x86)\OpenOffice 4\program目录下执行此命令，因此soffice不需要写全，否则需要写绝对路径。执行后cmd不会有等待占用窗口，会在后台启动服务。</p>
<p>有时候，可能莫名其妙的在服务器上有时候可以连接成功有时候就连接不上服务。所以可以试用jacob方式补充，但是经过测验，jacob比openOffice慢点，而且是越大越慢，但是转换ppt的时候openOffice却比较慢，无论怎么大jacob都比openOffice快。</p>
<h2 id="Jacob转换"><a href="#Jacob转换" class="headerlink" title="Jacob转换"></a>Jacob转换</h2><p>jacob转换时dll方式操作，需要将dll放到jdk/bin中。首先需要jacob.jar包。然后有一个dll。</p>
<p>有了这两个东西便可以进行转换了。</p>
<pre><code>public class JacobUtil &#123;
    private static Logger logger = Logger.getLogger(JocobUtil.class.getName());

    public static void main(String[] args) &#123;
        long b = System.currentTimeMillis();
        //ppt2Pdf(&quot;C:\\Users\\cgq_r\\Desktop\\iOS多边形.pptx&quot;,&quot;C:\\Users\\cgq_r\\Desktop\\iOS多边形.pptx&quot;);
        word2Pdf(&quot;C:\\Users\\cgq_r\\Desktop\\abc.doc&quot;,&quot;C:\\Users\\cgq_r\\Desktop\\abc.pdf&quot;);
        long c = System.currentTimeMillis();
        System.out.println(c-b);
    &#125;

    public static void ppt2Pdf(String src, String tar) &#123;
        ActiveXComponent app = null;
        Dispatch doc = null;
        try &#123;
            app = new ActiveXComponent(&quot;PowerPoint.Application&quot;);
            app.setProperty(&quot;AutomationSecurity&quot;, new Variant(3));
            Dispatch docs = app.getProperty(&quot;Presentations&quot;).toDispatch();
            doc = Dispatch.call(
                    docs,
                    &quot;Open&quot;,
                    new Object[] &#123; src, Boolean.TRUE, Boolean.TRUE,
                            Boolean.FALSE &#125;).toDispatch();
            Dispatch.call(doc, &quot;SaveAs&quot;,
                    new Object[] &#123; tar, Integer.valueOf(32) &#125;);
        &#125; finally &#123;
            if (doc != null) &#123;
                try &#123;
                    Dispatch.call(doc, &quot;Close&quot;);
                &#125; catch (Throwable t) &#123;
                    logger.log(Level.SEVERE, t.getMessage(), t);
                &#125;
            &#125;
            if (app != null) &#123;
                try &#123;
                    app.invoke(&quot;Quit&quot;);
                    app.safeRelease();
                &#125; catch (Throwable t) &#123;
                    logger.log(Level.SEVERE, t.getMessage(), t);
                &#125;
            &#125;
        &#125;
    &#125;

    public static void word2Pdf(String src, String tar) &#123;
        ActiveXComponent app = null;
        Dispatch doc = null;
        try &#123;
            app = new ActiveXComponent(&quot;Word.Application&quot;);
            app.setProperty(&quot;Visible&quot;, new Variant(false));
            app.setProperty(&quot;AutomationSecurity&quot;, new Variant(3));
            Dispatch docs = app.getProperty(&quot;Documents&quot;).toDispatch();
            doc = Dispatch.call(docs, &quot;Open&quot;,
                    new Object[] &#123; src, Boolean.FALSE, Boolean.TRUE &#125;)
                    .toDispatch();
            Dispatch.call(doc, &quot;SaveAs&quot;,
                    new Object[] &#123; tar, Integer.valueOf(17) &#125;);
        &#125; catch (Throwable t) &#123;
            logger.log(Level.SEVERE, t.getMessage(), t);
        &#125; finally &#123;
            if (doc != null) &#123;
                try &#123;
                    Dispatch.call(doc, &quot;Close&quot;, new Object[] &#123; Boolean.FALSE &#125;);
                &#125; catch (Throwable t) &#123;
                    logger.log(Level.SEVERE, t.getMessage(), t);
                &#125;
            &#125;
            if (app != null) &#123;
                try &#123;
                    app.invoke(&quot;Quit&quot;, new Variant[] &#123;new Variant(false)&#125;);
                    app.safeRelease();
                &#125; catch (Throwable t) &#123;
                    logger.log(Level.SEVERE, t.getMessage(), t);
                &#125;
            &#125;

        &#125;
    &#125;

    public static void excel2Pdf(String src, String tar) &#123;
        ActiveXComponent app = null;
        Dispatch doc = null;
        try &#123;
            app = new ActiveXComponent(&quot;Excel.Application&quot;);
            app.setProperty(&quot;Visible&quot;, new Variant(false));
            app.setProperty(&quot;AutomationSecurity&quot;, new Variant(3));
            Dispatch docs = app.getProperty(&quot;Workbooks&quot;).toDispatch();
            doc = Dispatch.call(docs, &quot;Open&quot;,
                    new Object[] &#123; src, Boolean.FALSE, Boolean.TRUE &#125;)
                    .toDispatch();
            Dispatch.call(doc, &quot;ExportAsFixedFormat&quot;,
                    new Object[] &#123; Integer.valueOf(0), tar &#125;);
        &#125; finally &#123;
            if (doc != null) &#123;
                try &#123;
                    Dispatch.call(doc, &quot;Close&quot;, new Object[] &#123; Boolean.FALSE &#125;);
                &#125; catch (Throwable t) &#123;
                    logger.log(Level.SEVERE, t.getMessage(), t);
                &#125;
            &#125;
            if (app != null) &#123;
                try &#123;
                    app.invoke(&quot;Quit&quot;);
                    app.safeRelease();
                &#125; catch (Throwable t) &#123;
                    logger.log(Level.SEVERE, t.getMessage(), t);
                &#125;
            &#125;
        &#125;
    &#125;

&#125;</code></pre>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Java/使用java gdal将shp文件转为geojson" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/01/02/Java/%E4%BD%BF%E7%94%A8java%20gdal%E5%B0%86shp%E6%96%87%E4%BB%B6%E8%BD%AC%E4%B8%BAgeojson/"
    >使用java gdal将shp文件转为geojson</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/01/02/Java/%E4%BD%BF%E7%94%A8java%20gdal%E5%B0%86shp%E6%96%87%E4%BB%B6%E8%BD%AC%E4%B8%BAgeojson/" class="article-date">
  <time datetime="2020-01-02T06:33:16.000Z" itemprop="datePublished">2020-01-02</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/">项目问题</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>原因描述:因为要使用乡镇级别的地图进行显示，但是网上都没有对应的geojosn格式的文件，最低到区县级别。网上说是可以手绘的，在geojson开源网站上绘制自动生成json。 <a target="_blank" rel="noopener" href="http://geojson.io/">http://geojson.io/</a></p>
<p>于是找了又找发现可将shp转为geojson格式，于是使用java gdal来转换shp为geojson文件。你只需要找shp文件即可了，如果没有找到，看看公司有没有arcgis相关的开发人员，问他们要。</p>
<p>首先需要下载包，从<a target="_blank" rel="noopener" href="http://download.gisinternals.com/sdk.php">http://download.gisinternals.com/sdk.php</a>中去下载，解压后进入release-版本好-x64/bin中,将当前目录下所有dll文件放到java 的jdk/bin下,然后进入./gdal/java目录,将下面的所有dll也放到jdk/bin下面，然后再把这些放到java功能根目录下,jar供程序使用。</p>
<p>1900版本gdal/java下只有gdal.jar和gdalalljni.dll,因此将dll分别分别放在jdk/bin下和项目根目录下即可。</p>
<pre><code>public class Application &#123;
    //http://download.gisinternals.com/sdk.php
    public static void main(String[] args) &#123;
        // 注册所有的驱动
        ogr.RegisterAll();
        // 为了支持中文路径，请添加下面这句代码
        gdal.SetConfigOption(&quot;GDAL_FILENAME_IS_UTF8&quot;,&quot;YES&quot;);
        // 为了使属性表字段支持中文，请添加下面这句
        gdal.SetConfigOption(&quot;SHAPE_ENCODING&quot;,&quot;&quot;);

        String strVectorFile = &quot;J:\\行政区\\XZQ.shp&quot;;
        //打开数据
        DataSource ds = ogr.Open(strVectorFile,0);
        if (ds == null)
        &#123;
            System.out.println(&quot;打开文件失败！&quot; );
            return;
        &#125;
        System.out.println(&quot;打开文件成功！&quot; );
        Driver dv = ogr.GetDriverByName(&quot;GeoJSON&quot;);
        if (dv == null)
        &#123;
            System.out.println(&quot;打开驱动失败！&quot; );
            return;
        &#125;
        System.out.println(&quot;打开驱动成功！&quot; );
        dv.CopyDataSource(ds, &quot;J:\\行政区\\fibercable.geojson&quot;);
        System.out.println(&quot;转换成功！&quot; );
    &#125;
&#125;</code></pre>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/" rel="tag">项目问题</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Hadoop/超简单基础搭建分布式hadoop" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/07/Hadoop/%E8%B6%85%E7%AE%80%E5%8D%95%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8Fhadoop/"
    >超简单基础搭建分布式hadoop</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/12/07/Hadoop/%E8%B6%85%E7%AE%80%E5%8D%95%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8Fhadoop/" class="article-date">
  <time datetime="2019-12-06T16:59:47.000Z" itemprop="datePublished">2019-12-07</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hadoop/">Hadoop</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>新文章，之前的hadoop部署文章教程均可能出现问题，仅作为参考。以本文为准</p>
<h1 id="第一章-虚拟机配置"><a href="#第一章-虚拟机配置" class="headerlink" title="第一章 虚拟机配置"></a>第一章 虚拟机配置</h1><p>创建centos7.x虚拟机不再描述,网卡连接方式使用NAT方式</p>
<p><strong>网络问题,创建NAT虚拟网络</strong><br>可在VMware的编辑，虚拟网络编辑器中，添加网络，点击右下角的管理员操作权限，点击添加网络按钮，随意选一个VMnet，选择VMnet为NAT模式。<br>勾选将主机虚拟适配器连接到此网络和勾选使用本地DHCP服务将IP地址分配给虚拟机。然后可以修改HDCP设置，默认可以不更改。</p>
<h2 id="创建完虚拟机后，无法使用sudo问题"><a href="#创建完虚拟机后，无法使用sudo问题" class="headerlink" title="创建完虚拟机后，无法使用sudo问题"></a>创建完虚拟机后，无法使用sudo问题</h2><p>使用命令<code>su root</code>进入root用户,执行<code>visudo</code>命令打开sudoer文件,找到</p>
<pre><code>root    ALL=(ALL)       ALL</code></pre><p>在其下面添加与其一样的一行，并把root改为自己的用户名,然后保存退出,如:</p>
<pre><code>centos    ALL=(ALL)       ALL</code></pre><h2 id="安装jdk和hadoop"><a href="#安装jdk和hadoop" class="headerlink" title="安装jdk和hadoop"></a>安装jdk和hadoop</h2><p>jdk选JDK8的,hadoop建议选择3.x版本的，这里，我使用JDK8和hadoop3.1.3。目前JDK11与hadoop3.x版本的匹配问题还没有找到解决办法，使用jdk会导致在启动时出现java.lang.ClassNotFoundException: javax.activation.DataSource的异常。</p>
<pre><code>[centos@centos3 ~]$ java -version
java version &quot;1.8.0_231&quot;
Java(TM) SE Runtime Environment (build 1.8.0_231-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.231-b11, mixed mode)
[centos@localhost ~]$ hadoop version
Hadoop 3.1.3
Source code repository https://gitbox.apache.org/repos/asf/hadoop.git -r ba631c436b806728f8ec2f54ab1e289526c90579
Compiled by ztang on 2019-09-12T02:47Z
Compiled with protoc 2.5.0
From source with checksum ec785077c385118ac91aadde5ec9799
This command was run using /home/centos/hadoop/share/hadoop/common/hadoop-common-3.1.3.jar</code></pre><p>将jdk8和hadoop解压，放置在~/下,在/etc/profile中配置环境变量,<code>sudo vim /etc/profile</code>命令，打开后在结尾追加</p>
<pre><code>export JAVA_HOME=/home/centos/jdk8
export PATH=$JAVA_HOME/bin:$PATH
export HADOOP_HOME=/home/centos/hadoop
export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH</code></pre><p>然后使用<code>source /etc/profile</code>编译文件。然后可以输入上面的版本命令，看看信息。</p>
<h2 id="暂时关闭防火墙"><a href="#暂时关闭防火墙" class="headerlink" title="暂时关闭防火墙"></a>暂时关闭防火墙</h2><pre><code>systemctl stop firewalld.service</code></pre><h2 id="规定三台服务器的IP-这个ip地址是随意的。"><a href="#规定三台服务器的IP-这个ip地址是随意的。" class="headerlink" title="规定三台服务器的IP,这个ip地址是随意的。"></a>规定三台服务器的IP,这个ip地址是随意的。</h2><pre><code>192.168.181.129 centos1
192.168.181.130 centos2
192.168.181.131 centos3</code></pre><p>修改/etc/host文件，配置映射文件,将上面的配置放在该文件中。</p>
<h2 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h2><p>关闭虚拟机，点击菜单栏的虚拟机，选择管理，选择克隆，选择完全克隆，选择存储位置，然后进行克隆。如果你的当前磁盘是固态，那么是非常非常快的，不超过1分钟。</p>
<h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><p>打开全部虚拟机，其实完全克隆后，主机名已经变了，从centos1到centos3，hostname是直接改过了的。你可以到设置-详细信息-用户里改一下用户名称为主机名名称。<br>然后配置一下另外两个的网络,这里配ip，上面好像没说。可以直接到设置-网络，点有线连接下的那个网卡点IPV4，设为手动，分别填写，你在虚拟网络配置里配置的网络ip，或者可以不用这用，因为是hdcp的，所以直接ifconfig查看ip结构，把之前预先设计好的ip填进去，并把地址和子网掩码放进去，网关为.1，DNS设为114.114.114.114。然后ipv6这点击禁用。<br>然后尝试互相ping并ping一下<a target="_blank" rel="noopener" href="http://www.baidu.com看是否外网可以通。">www.baidu.com看是否外网可以通。</a><br>如果找不到地方，看不到英文的话，可以设置成中文，点设置-region-language，看上部分，选择语言，汉语中文，然后根据他的提示重启一下就好了，让修改home下的文件名称的话，<strong>选不修改且不再提示</strong>。</p>
<h2 id="虚拟机免密登录"><a href="#虚拟机免密登录" class="headerlink" title="虚拟机免密登录"></a>虚拟机免密登录</h2><p>在三台机器都执行以下指令</p>
<pre><code>ssh-keygen -t rsa ；
ssh-copy-id IP (自身)
ssh-copy-id IP (其他节点)</code></pre><p>执行第一条指令时，回车三次，第二条和第三条是一样的，输入yes，然后输入ip的密码。<br>这三条指令，每台机器都执行一遍。<br>执行完毕后，从129开始，ssh centos1,ssh centos2,ssh centos3,三台机器都执行一遍这三个命令，表示要ssh连接一次，记住ip。</p>
<h1 id="第二章-集群配置"><a href="#第二章-集群配置" class="headerlink" title="第二章 集群配置"></a>第二章 集群配置</h1><h2 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h2><p>centos1</p>
<p>centos2</p>
<p>centos3</p>
<p>HDFS</p>
<p>NameNode<br>DataNode</p>
<p>DataNode</p>
<p>SecondaryNameNode<br>DataNode</p>
<p>YARN</p>
<p>NodeManager</p>
<p>NodeManager<br>ResourceManager</p>
<p>NodeManager</p>
<p>每个DataNode一定是有个NodeManager的。NameNode是比较重要的，管理所有的节点，所以一般是单独占一个服务器，但是只有三台机器又要做三个机器的数据存储。</p>
<h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><p>进入hadoop的etc/hadoop</p>
<ol>
<li><p>配置hadoop-env.sh，找到被注释的JAVA_HOME与HADOOP_HOME，解开注释，修改为对应位置。</p>
</li>
<li><p>修改core-site.xml,添加如下</p>
<!-- 指定HDFS中的NameNode地址 -->
<property>
<name>fs.defaultFS</name>
   <value>hdfs://centos1:9000</value>
</property>
<!-- 指定hadoop运行时产生的临时文件 -->
<property>
<name>hadoop.tmp.dir</name>
   <value>/home/centos/hadoop/data/hadoopdata</value>
</property>
</li>
<li><p>修改hdfs-site.xml，添加如下</p>
<property>
    <name>dfs.namenode.secondary.http-address</name>
        <value>centos3:50090</value>
    <description>secondarynamenode运行节点的信息,和namenode不同节点</description>
</property>
<property>
        <name>dfs.replication</name>
        <value>3</value>
    <description>HDFS的数据块副本存储个数</description>
</property>
<property>
    <name>dfs.namenode.http-address</name>
    <value>centos1:50070</value>
</property>
<property>
        <name>dfs.namenode.name.dir</name>
        <value>/home/centos/hadoop/data/name</value>
    <description>namenode的数据存储目录</description>
</property>
<property>
        <name>dfs.datanode.data.dir</name>
        <value>/home/centos/hadoop/data/data</value>
    <description>datanode的数据存储目录</description>
</property>
</li>
<li><p>修改yarn-site.xml，添加如下</p>
<property>
        <name>yarn.resourcemanager.hostname</name>
        <value>centos2</value>
</property>
<property>
        <name>yarn.nodemanager.aux-services</name>
        <value>mapreduce_shuffle</value>
        <description>yarn集群为mapreduce程序提供的shuffle服务</description>
</property>

</li>
</ol>
<p>有时候，有的yarn还是什么日志报错，具体问题忘了，是需要配置<code>yarn.application.classpath</code>的属性，它的值通过<code>hadoop classpath</code>命令打出来</p>
<pre><code>&lt;property&gt;
&lt;name&gt;yarn.application.classpath&lt;/name&gt;
&lt;value&gt;/home/hadoop/install/hadoop/etc/hadoop:/home/hadoop/install/hadoop/share/hadoop/common/lib/*:/home/hadoop/install/hadoop/share/hadoop/common/*:/home/hadoop/install/hadoop/share/hadoop/hdfs:/home/hadoop/install/hadoop/share/hadoop/hdfs/lib/*:/home/hadoop/install/hadoop/share/hadoop/hdfs/*:/home/hadoop/install/hadoop/share/hadoop/mapreduce/lib/*:/home/hadoop/install/hadoop/share/hadoop/mapreduce/*:/home/hadoop/install/hadoop/share/hadoop/yarn:/home/hadoop/install/hadoop/share/hadoop/yarn/lib/*:/home/hadoop/install/hadoop/share/hadoop/yarn/*&lt;/value&gt;
&lt;/property&gt;</code></pre><ol>
<li><p>修改mapred-site.xml，添加如下</p>
<property>
        <name>mapreduce.framework.name</name>
        <value>yarn</value>
</property>
<property>
        <name>mapreduce.jobhistory.address</name>
        <value>centos1:10020</value>
</property>
<property>
        <name>mapreduce.jobhistory.webapp.address</name>
        <value>centos1:19888</value>
</property>

</li>
</ol>
<h2 id="hadoop拷贝到centos2和centos3"><a href="#hadoop拷贝到centos2和centos3" class="headerlink" title="hadoop拷贝到centos2和centos3"></a>hadoop拷贝到centos2和centos3</h2><p>之前的克隆的时候的从centos1中克隆来的，但没有配置，在这里，先把centos2和centos3的hadoop目录删了，通过命令吧刚配置的centos1的hadoop拷贝过去。当前，如果读到这，你还没有克隆的话，先把这里的配置配了再克隆吧</p>
<pre><code>scp -r ./hadoop centos@centos2:~/
scp -r ./hadoop centos@centos3:~/</code></pre><h2 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h2><ol>
<li><p>首先执行一次格式化hdf,centos1中(namenode)<br>这是必须的，但下此再要重启服务的话就不需要了。</p>
<p>[centos@centos1 hadoop]$ hdfs namenode -format<br>2019-12-06 08:00:49,798 INFO namenode.NameNode: STARTUP_MSG:<br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>STARTUP_MSG: Starting NameNode<br>STARTUP_MSG:   host = centos1/192.168.181.129<br>STARTUP_MSG:   args = [-format]<br>STARTUP_MSG:   version = 3.1.3<br>STARTUP_MSG:   classpath = /home/centos/hadoop/etc/hadoop:/home/ce<br>….省略</p>
</li>
<li><p>启动start-dfs,start-yarn</p>
</li>
</ol>
<p>在centos1中，也就是namenode中启动<code>start-dfs.sh</code>,必须在namenode中启动<br>然后去centos2,也就是resourceManager，<code>start-yarn.sh</code>,必须在resourceManager上启动<br>以上的启动位置，是强制的，否则出现服务启动缺失等其他异常情况。</p>
<pre><code>[centos@centos1 hadoop]$ start-dfs.sh 
Starting namenodes on [centos1]
Starting datanodes
Starting secondary namenodes [centos3]
[centos@centos2 hadoop]$ start-yarn.sh 
Starting resourcemanager
Starting nodemanagers
[centos@centos1 hadoop]$ jps
15426 NameNode
15938 Jps
15561 DataNode
15868 NodeManager
[centos@centos2 hadoop]$ jps
15028 ResourceManager
15428 Jps
14872 DataNode
15161 NodeManager
[centos@centos3 hadoop]$ jps
14214 SecondaryNameNode
14104 DataNode
14317 NodeManager
14414 Jps</code></pre><p>这里，因为测试的时候忘记执行<code>hdfs namenode -format</code>命令了，所以出现了错误，所以日志目录没有删除，这里如果第一次启动的话会提示WARN没有logs文件，会自动创建。不必在意。</p>
<p>以上服务，一个都不能少。如果少了哪个，则查看nameNode机器的日志或其他节点的日志。<br>如果集群启动失败，则必须把服务先关停，然后删除每个节点的data 和logs目录，然后再hdfs namenode -format。</p>
<p>记得关闭防火墙，避免无法访问web服务，如果不想关闭，那么去开放端口吧。每次重启需要执行关闭命令，也可以永久关闭。</p>
<pre><code># 查看状态
systemctl status firewalld.service
# 临时关闭
systemctl stop firewalld.service</code></pre><p>然后可以再宿主机上，通过访问centos1的ip地址:50070端口即可访问web页面。这里的地址是192.168.181.129:50070.<br>进入后选择最后一项Utilities，选择呢Brower the file system即可看到HDFS文件系统。</p>
<h2 id="HDFS文件测试"><a href="#HDFS文件测试" class="headerlink" title="HDFS文件测试"></a>HDFS文件测试</h2><pre><code>hdfs dfs -mkdir -p /user/input
hdfs dfs -put abc.txt /user/input

hdfs dfs -mkdir -p /user/package
hdfs dfs -put ~/jdk-8u231-linux-x64.tar.gzip /user/package</code></pre><p>上传了一个小文件，一个大文件。查看centos1:50070,发现是有的。以128M为一个block，abc.txt占用一个块，jdk为俩个块。</p>
<p>如何在本地查找,进入到data目录中找<br><code>/home/centos/hadoop/data/data/current/BP-2112740988-192.168.181.129-1562738006972/current/finalized/subdir0/subdir0</code></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-SpringCloud/SpringCloud项目基础搭建2" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/03/SpringCloud/SpringCloud%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA2/"
    >SpringCloud项目基础搭建2</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/11/03/SpringCloud/SpringCloud%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA2/" class="article-date">
  <time datetime="2019-11-03T09:01:49.000Z" itemprop="datePublished">2019-11-03</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringBoot/">SpringBoot</a> / <a class="article-category-link" href="/categories/SpringBoot/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>基本结构已经搭起来了,使用的是feign进行访问的。<br>接下来我们继续完善这个项目，做到更加的适用可靠。<br>项目均使用的yml配置文件，但是文章中使用properties的.符号来代替文章格式显示的问题。</p>
<p>以下项目的配置，如果说出现报错的问题，也就是说最开始没问题，改了哪个不影响的地方却突然出问题。任何问题首先clean，重新package，在重新启动一下。看看有没有解决，如果开没有解决，就检查一下当前报错应用的配置文件，最后再去百度上搜。</p>
<h2 id="配置服务的info信息"><a href="#配置服务的info信息" class="headerlink" title="配置服务的info信息"></a>配置服务的info信息</h2><p>服务的info信息可以再注册中心查看，可以描述说明当前服务主要是干什么的。访问服务即可进入一个json打开的页面。<br>我们来注册服务者的info信息,项目结构在上一篇已经有了。下面的依赖actuator可以直接放在cloudservice这个模块中就可以</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre><p>然后再build元素里添加如下内容</p>
<pre><code>&lt;build&gt;
    &lt;finalName&gt;USER-SERVICE&lt;/finalName&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;delimiters&gt;
                    &lt;delimit&gt;$&lt;/delimit&gt;
                &lt;/delimiters&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre><p>最后,服务的info信息在application.yml里配置。</p>
<pre><code>info:
  app.name: USER-SERVICE-9001
  company.name: www.fsats.com
  build.artifactId: @project.artifactId@
  build.version: @project.version@</code></pre><p>这里呢，其实应该是$符号不该是@,因为已经在pom中定义过了，但是总是个别问题出现，网上也有情况，这里也不描述为什么出现这总情况，不深究这些。</p>
<p>默认呢,actuator会给我们两个接口,info和health分别表示应用信息和健康指标,还有一个单独的根节点访问。另外还有其他的访问节点，但是并没有默认对外暴露，在官方文档上都有，可以进行开启。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://192.168.88.1:9001/actuator/info">http://192.168.88.1:9001/actuator/info</a></li>
<li><a target="_blank" rel="noopener" href="http://192.168.88.1:9001/actuator/health">http://192.168.88.1:9001/actuator/health</a></li>
<li><a target="_blank" rel="noopener" href="http://192.168.88.1:9001/actuator">http://192.168.88.1:9001/actuator</a></li>
</ul>
<p>文档<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/actuator-api/html/#overview描述了actuator的所有提供信息端点。">https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/actuator-api/html/#overview描述了actuator的所有提供信息端点。</a><br>我们在application.yml中输入management.endpoints.web就可以自动提示叫base-path的，他的路径默认值是/actuator，也就是访问的名称，是可以改的，然后引入端点的话是management.endpoints.web.exposure.include，它是一个数组，默认值就是info和health,我们可以依据文档上新增,如果要引入全部的话可以吧值写成 “*” ，注意包含双引号。然后访问actuator就可以显示了。</p>
<p>如果想修改访问名称，也就是映射，可以设置path-mapping属性，他是一个map形式。</p>
<p>哦对了，这个东西页面可以直接在eureka页面中点服务的名称就可以跳转到actuator页面了。其他的可以看官网和其他博客看。</p>
<h2 id="注册实例名称的修改和左下角ip更改"><a href="#注册实例名称的修改和左下角ip更改" class="headerlink" title="注册实例名称的修改和左下角ip更改"></a>注册实例名称的修改和左下角ip更改</h2><p>注册实例id是唯一的通过eureka.instance.instance-id设置一个值。这样页面上就会变。然后你碰status后，左下角不是ip路径而是服务名称，要改成ip的话只需要配置eureka.instance.prefer-ip-address: true即可。</p>
<h2 id="eureka服务实例的自我保护机制-了解"><a href="#eureka服务实例的自我保护机制-了解" class="headerlink" title="eureka服务实例的自我保护机制(了解)"></a>eureka服务实例的自我保护机制(了解)</h2><p>自我保护机制是应对注册进注册中心的服务的，当服务注册进后，服务会向注册中心发送特定消息(心跳)，eureka server会接收到,在一定时间内(默认90秒，可以修改)没有收到某个微服务的心跳，eureka server便会移除这个注册服务实例，而某些情况可能只是网络通信的原因导致心跳消息无法及时发送到，导致实例被移除，因此引入了自我保护机制，该微服务实例并不会移除。</p>
<p>那自我保护机制是怎么个机制，如果接受的心跳在15分钟内低于应收总量的85%，那么这个实例就会处于保护状态，那么这个实例就不会过期。而如果收到的请求回到那个阙值，就会关闭保护机制。</p>
<p>但如果开启了保护机制，万一请求到这个实例，那么就处于非正常的请求，可能是空的或者是错误请求。我们可以取消保护机制，那么在一定时间内该实例就会被下线，不会再注册中心中出现。</p>
<p>eureka server关闭自我保护:eureka.server.enable-self-preservation: false<br>微服务注册客户端设置心跳:</p>
<ul>
<li>lease-expiration-duration-in-seconds: 90 #表示若90秒内没有发送服务端心跳，说明服务为Down状态</li>
<li>lease-renewal-interval-in-seconds: 30 #表示每30秒向服务端发送一次心跳，保证出于连接状态</li>
</ul>
<h2 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h2><p>首先eureka是注册中心，所有服务都注册于此，但难免某个服务所在的服务器出现问题或网络出现问题，这样，当某用户在请求时，刚好将请求分配到这个服务实例去响应，然而却无法通信，可能就会出现无响应或者请求阻塞等问题。<br>这也是，如果eureka server的自我保护机制中如果出现了这种问题，那么请求不也有问题了么。</p>
<p>因此就有负载均衡来解决这个问题，通常的单机应用程序，可以使用nginx，多台服务器启动多个程序，并使用nginx来进行负载均衡，属于集中式的。<br>而我们现在要说的Netflix Ribbon是进程式的，可以嵌入到消费者服务中，从注册中心中获取哪个服务地址有用，在选择适合的服务器请求</p>
<p>因为Ribbon是嵌入到服务消费者中的，因此在eureka-consumer中配置<br>添加依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;
    &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>然后第二步时创建数据库,分别再创建cloud2和cloud3，用来表示另外两个userservice服务的各自的库，并把user表给建上。</p>
<p>然后第三步是,新建模块userservice2和userservice3,将java下的包和resources下的mapper及application.yml拷贝一份。然后修改，端口号为9002和9002，修改instance-id的命名，修改数据库分别为cloud2和cloud3,修改info.app.name的名字。<br><strong>除了更改配置文件，其他的是完全一模一样的</strong>。</p>
<p>然后就可以测试了，之前在单个服务的时候已经测试过了，cloud1里面也已经有数据了，然后当我们执行<a target="_blank" rel="noopener" href="http://loclahost:8001/consumer/user/list的时候，发现每执行3次会查询出一次结果，因为其中一个库有数据，另两个是新建的没有数据。而这种查询的负载均衡就是默认的轮询模式，多个服务循环依次请求。">http://loclahost:8001/consumer/user/list的时候，发现每执行3次会查询出一次结果，因为其中一个库有数据，另两个是新建的没有数据。而这种查询的负载均衡就是默认的轮询模式，多个服务循环依次请求。</a><br>我们看一下现在包的结构:</p>
<p><img src="https://i.loli.net/2019/11/02/l4De82QVfRWxihN.png" alt="title"></p>
<p>然后我们说一下负载均衡的策略，默认的轮询模式已经知道是怎么个形式了。拿一个表，列出其他的模式</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RoundRobinRule</td>
<td>轮询,按照定义顺序一次循环访问</td>
</tr>
<tr>
<td>RandomRule</td>
<td>随机进行访问</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阙值的服务，然后对剩余服务列表按照轮询策略访问</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>根据平均响应时间计算所有服务的权重，响应时间越快的服务权重越大被选中的概率越高，如果刚启动统计信息不足，则使用RoundRobinRule策略，等统计信息足够时，切换到WeightedResponseTimeRule</td>
</tr>
<tr>
<td>RetryRule</td>
<td>先按照RoundRobinRule的策略获取服务，如果获取失败则在指定时间内进行重试，获取可用的服务</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择并发量最小的服务</td>
</tr>
<tr>
<td>ZoneAvoidanceRule</td>
<td>复合判断server所在区域的性能和server的可用性选择服务器</td>
</tr>
</tbody></table>
<p>如果要修改默认的策略，只需要注入对应的Bean就好了。处于cfg包里</p>
<pre><code>@Configuration
public class MyConfiguration &#123;

    @Bean
    public IRule myRule()&#123;
        return new RandomRule();
    &#125;
&#125;</code></pre><p>当然这是对当前应用所有请求都是用这个规则，如果你的这个消费者模块想要处理两个模块的请求，可以分开处理请求规则。你可以在启动类上标注注解</p>
<pre><code>@RibbonClient(name = &quot;SPRING-PROD&quot;,configuration = RoundRobinRule.class)
@EnableFeignClients(basePackages = &#123;&quot;com.fsats.user&quot;&#125;)
@EnableEurekaClient
@SpringBootApplication
public class ConsumerApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(ConsumerApplication.class,args);
    &#125;
&#125;</code></pre><p>这个注解使用的是应对单个模块SPRING-PROD，configuration属性就是规则类。如果因为业务需要这个应用程序处理两个模块的业务，那么么可以使用@RibbonClients注解。另外，在注解上标注的和通用配置的不能重复。否则会报错说找到两个匹配的规则。</p>
<p><strong>自定义规则</strong><br>自定义规则也是在configuration中配置，可以继承AbstractLoadBalancerRule类来配置规则。<br>我们在cfg包里创建MyRule类</p>
<pre><code>public class MyRule extends AbstractLoadBalancerRule &#123;

    @Override
    public void initWithNiwsConfig(IClientConfig iClientConfig) &#123;

    &#125;

    private int total = 0;            // 总共被调用的次数，目前要求每台被调用5次
    private int currentIndex = 0;    // 当前提供服务的机器号

    public Server choose(ILoadBalancer lb, Object key) &#123;
        if (lb == null) &#123;
            return null;
        &#125;
        Server server = null;

        while (server == null) &#123;
            if (Thread.interrupted()) &#123;
                return null;
            &#125;
            List&lt;Server&gt; upList = lb.getReachableServers();
            List&lt;Server&gt; allList = lb.getAllServers();

            int serverCount = allList.size();
            if (serverCount == 0) &#123;
                return null;
            &#125;
            if (total &lt; 5) &#123;
                server = upList.get(currentIndex);
                total++;
            &#125; else &#123;
                total = 0;
                currentIndex++;
                if (currentIndex &gt;= upList.size()) &#123;
                    currentIndex = 0;
                &#125;
            &#125;
            if (server == null) &#123;
                Thread.yield();
                continue;
            &#125;
            if (server.isAlive()) &#123;
                return (server);
            &#125;
            server = null;
            Thread.yield();
        &#125;

        return server;

    &#125;

    @Override
    public Server choose(Object o) &#123;
        return choose(getLoadBalancer(),o);
    &#125;
&#125;</code></pre><p>该类定义规则是每个服务都请求5次后再请求下一个服务。然后更改MyConfiguration的注入的规则Bean，注入MyRule。然后修改注解上的配置类MyConfiguration.class,或者直接把MyRule.class写在configuration属性上。</p>
<h2 id="Hystrix断路器"><a href="#Hystrix断路器" class="headerlink" title="Hystrix断路器"></a>Hystrix断路器</h2><p>服务器负载均衡的策略已经说好了，那如果程序出现异常错误，请求超时等等其他问题该怎么办，如果特殊原因把某个服务停了，而刚好请求到这里该怎么办。<br>断路器，字面意思就如电路保险丝一样。<br>Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</p>
<h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>服务熔断，可以理解为当客户端访问服务时，因为服务的原因，导致服务响应报错，或响应失败，导致响应超时造成资源损失，作出的处理(<strong>向调用方法返回一个符合预期的可处理的备选响应Fallback</strong>),而不是一直等待响应或抛出异常。<br>如果执行一个方法报错了，怎么办，我们来模拟一下:<br>在consumer添加依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre><p>在UserController中添加方法,请求路径get改为getn,然后添加注解，配置fallbackMethod为某个方法名称</p>
<pre><code>@HystrixCommand(fallbackMethod = &quot;requestErrorGet&quot;)
@GetMapping(&quot;/consumer/user/getn/&#123;id&#125;&quot;)
public User getWithNull(@PathVariable(&quot;id&quot;) Long id)&#123;
    User user = iUserClient.get(id);
    if (user==null)&#123;
        throw new RuntimeException();
    &#125;
    return user;
&#125;

public User requestErrorGet(@PathVariable(&quot;id&quot;) Long id)&#123;
    return new User().setId((long) 0).setName(&quot;没有找到记录&quot;).setAge((long) 21);
&#125;</code></pre><p>然后给consumer启动类添加@EnableCircuitBreaker注解。即可测试，发现如果数据入库请求请求到cloud2或cloud3，就会获取null，然后抛出异常，就执行requestErrorGet方法了。</p>
<h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>服务降级属于服务的较大问题，例如服务所在服务器关机或其他情况，导致访问服务无法响应。与熔断的区别在于，服务熔断其服务是可用的，但服务降级的问题是可能服务不可用，在注册中心处于Down状态。即服务为暂停状态，无法访问。此时做服务降级处理。任何访问此服务的都会返回相应的自定义信息。<br>而因为诸多个方法，每个方法都需要一个熔断后处理方法，所以，他需要一个FallbackFactory来集中处理每个服务中方法的请求。它放在Feign中，也是与实际业务解耦。<br>所以服务降级的配置在api模块上，api模块要请求服务提供者，但服务提供者挂了。那么这个就会被触发。但是如果同时配置服务熔断，那么会先执行服务熔断@HystrixCommand注解上的fallbackMethod。因此这里我们先把这个注解注释掉。</p>
<p>配置api模块,在feign包同级创建fallback包，创建类</p>
<pre><code>@Component
public class UserClientFallbackFactory implements FallbackFactory&lt;IUserClient&gt; &#123;
    @Override
    public IUserClient create(Throwable throwable) &#123;
        return new IUserClient() &#123;
            @Override
            public boolean add(User user) &#123;
                return false;
            &#125;

            @Override
            public User get(Long id) &#123;
                return new User().setId((long) 0).setName(&quot;服务降级&quot;).setAge((long) 0);
            &#125;

            @Override
            public List&lt;User&gt; list() &#123;
                return new ArrayList&lt;&gt;();
            &#125;
        &#125;;
    &#125;
&#125;</code></pre><p>然后再feign中IUserClient接口类上的@FeighClient注解上新增属性fallbackFactory,然后现在是这样的@FeignClient(value = “SPRING-PROD”,fallbackFactory = UserClientFallbackFactory.class)<br>最后在consumer上加上配置，开启feign和Hystrix，feign.hystrix.enabled:true</p>
<p>接下来测试，首先把consumer的@HystrixCommand注解注释掉，这个会在服务降级之前处理。/consumer/user/getn/1<br>我们只启动ecurekaServer和consumer来测试，服务提供者均不启动，当我们请求get的时候，因为api那请求服务提供者不了啊，所以就进入那个类的方法里，打印了服务降级的信息。<br>那我们此时再启动三个服务提供者，会发现有时候有结果，有时候报错，因为cloud1有数据，而且服务熔断的注释被注掉了，所以请求到另两个的时候会报错。<br>现在，再停止consumer，把@HystrixCommand服务熔断注释解开，在重新启动，再请求发现，有的是返回正确信息，有的返回没有记录(cloud2，cloud3)。</p>
<h3 id="hystrixDashboard服务调用监控"><a href="#hystrixDashboard服务调用监控" class="headerlink" title="hystrixDashboard服务调用监控"></a>hystrixDashboard服务调用监控</h3><p>Hystrix会持续记录所有通过Hystrix发起的请求的执行信息，以统计报表和图形的方式展现给用户，每秒执行多少成功，多少失败等等。<br>Spring Cloud提供Hystrix Dashboard的整合将监控内容转化成可视化界面。</p>
<p>我们为三个userservice添加依赖，可以放在父pom里</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre><p>然后为各自启动类添加@EnableHystrixDashboard注解<br>因2.0版本情况原因，还需要在userservice中配置一段代码,才能访问</p>
<pre><code>@Configuration
public class MyConfiguration &#123;

    @Bean
    public ServletRegistrationBean hystrixMetricsStreamServlet() &#123;
        ServletRegistrationBean registration = new ServletRegistrationBean(new HystrixMetricsStreamServlet());
        registration.addUrlMappings(&quot;/hystrix.stream&quot;);
        return registration;
    &#125;
&#125;</code></pre><p>访问<a target="_blank" rel="noopener" href="http://lcoalhost:9001/hystrix可以访问搭配监控页面,在地址栏输入`http://localhost:9001/hystrix.stream`,下面可是输入刷新间隔个监控名称。点击按钮即可进入监控。">http://lcoalhost:9001/hystrix可以访问搭配监控页面,在地址栏输入`http://localhost:9001/hystrix.stream`,下面可是输入刷新间隔个监控名称。点击按钮即可进入监控。</a></p>
<p>不过奇怪的是，一直loding中，没有图像显示,因为他必须要在经过请求的方法上添加@HystrixCommand注解来监控，因此需要在userservice的UserController的方法上添加此注解。然后再多次请求就有结果了。</p>
<p>不过更奇怪的是，再服务熔断的时候不是配置在consumer中了么。可见好像配置的位置不怎么正确，不过功能依据注解，还是可以使用的。<br>但是，我们尝试把consumer的服务熔断给取消掉，然后由userservice来处理服务熔断这个问题，发现，是没有问题的。可以放在userservice中，那么这个监控的问题就顺理成章了。</p>
<p>此时我们的consumer就还是feign和ribbon负载均衡了。而uservice则承载着服务熔断和服务监控，而api依旧是负责服务降级的问题。</p>
<p>我列一下userservice的UserController和启动类</p>
<pre><code>@RestController
public class UserController &#123;

    @Autowired
    private UserService userService;

    @ResponseBody
    @PostMapping(&quot;/user/add&quot;)
    public boolean add(@RequestBody User user)&#123;
        return userService.add(user);
    &#125;
    @HystrixCommand(fallbackMethod = &quot;requestErrorGet&quot;)
    @ResponseBody
    @GetMapping(&quot;/user/get/&#123;id&#125;&quot;)
    public User get(@PathVariable(&quot;id&quot;) Long id)&#123;
        User user = userService.get(id);
        if (user==null)&#123;
            throw  new RuntimeException();
        &#125;
        return user;
    &#125;

    @ResponseBody
    @GetMapping(&quot;/user/list&quot;)
    public List&lt;User&gt; list()&#123;
        return userService.list();
    &#125;

    public User requestErrorGet(@PathVariable(&quot;id&quot;) Long id)&#123;
        return new User().setAge((long) 0).setName(&quot;Asd&quot;).setId((long) 0);
    &#125;
&#125;

@EnableCircuitBreaker
@EnableHystrixDashboard
@EnableEurekaClient
@SpringBootApplication
public class UserServiceApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(UserServiceApplication.class,args);
    &#125;
&#125;</code></pre><p>application.yml是没变的，pom是父pom添加的依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre><p>consumer的启动类</p>
<pre><code>@RibbonClient(name = &quot;SPRING-PROD&quot;,configuration = RoundRobinRule.class)
@EnableFeignClients(basePackages = &#123;&quot;com.fsats.user&quot;&#125;)
@EnableEurekaClient
@SpringBootApplication
public class ConsumerApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(ConsumerApplication.class,args);
    &#125;

&#125;</code></pre><p>项目下载:<a target="_blank" rel="noopener" href="https://nas.tsaving.cn/file/download/72">https://nas.tsaving.cn/file/download/72</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-SpringCloud/SpringCloud项目基础搭建1" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/01/SpringCloud/SpringCloud%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA1/"
    >SpringCloud项目基础搭建1</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/11/01/SpringCloud/SpringCloud%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA1/" class="article-date">
  <time datetime="2019-11-01T12:57:49.000Z" itemprop="datePublished">2019-11-01</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringBoot/">SpringBoot</a> / <a class="article-category-link" href="/categories/SpringBoot/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>首先从可以通信开始，然后再配置负载均衡熔断器之类的。<br>首先，学完了springcloud之后，许多名词，虽然了解一点，但是他们之间的关系还是不太明确清晰。<br>分布式微服务，既然是分布式肯定会通信的，离不开ip的。</p>
<p>服务注册:也就是注册中心，通俗一点就是 将服务提供者注册到这个服务中心中，<strong>由注册中心来进行资源调配管理，上线下线等</strong>，服务提供者可以同时注册多个，可以负载均衡。</p>
<p>服务提供者:就是平常写的一套单机程序，controller，service,mapper一整套代码，它能对外提供接口，因此被称为提供者，他需要注册到注册中心去</p>
<p>服务消费者:也就是对外部开放的,而提供者可以不对外开放，也就是说，浏览器直接调用服务消费者的代码，而在后台，直接由服务消费者请求服务提供者，而中间请求的过程就是请求服务注册中心，由他来确定请求哪个服务提供者的服务。</p>
<p>简而言之,服务注册是管理所有的服务，服务提供者对内，服务消费者对外。<br>服务消费者通过什么调用请求注册中心调用服务提供者,Feign。<br>Feign是一个声明式的Web Service客户端，它的目的是让Web Service调用更简单。Feign提供了HTTP请求的模板，通过编写简单的接口和插入注解，就可以定义好HTTP请求的参数、格式、地址等信息。</p>
<p>虽然说到这，基本简单的微服务已经形成了，但是还无法明确项目搭建的机构。Feign，服务消费者，服务提供者该往哪写。</p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>springcloud如果没有教程入门，可能还没进门就卡死在外。<br>springboot 与springcloud，springcloud是依赖springboot的，而springboot的版本有1.x和2.x，而2.x又分为2.1和2.2。而springcloud的版本号却不是以数字命名，这就很难搞。而且两者版本的依赖是有非常严格的，否则就会莫名的出错，甚至连项目都起不来。springboot2.1和2.2也有很大的区别，以及springcloud的不同版本引用有有较大的改动。<br>还有就是依赖的问题,老版本的eureka依赖名教eureka，而新版本的叫eureka-server，feign也有老版和新版,为openfeign和feign。<br>通过教程的学习以及多次尝试，最后找到匹配的版本。</p>
<p><strong>父工程POM</strong></p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
&lt;properties&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;spring-cloud.version&gt;Greenwich.BUILD-SNAPSHOT&lt;/spring-cloud.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--&lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
    &lt;/dependency&gt;--&gt;
    &lt;!--&lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt;
    &lt;/dependency&gt;--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;version&gt;1.1.16&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre><p>以上的版本匹配是:<br>SpringBoot:2.1.6.RELEASE<br>SpringCloud:Greenwich.BUILD-SNAPSHOT<br>这个是没有问题的。</p>
<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>服务注册是用eureka,分为eureka-server和eureka-client。<br>server及服务注册中心本身，他也是服务，但他不需要注册自己，只作为服务管理者。<br>模块名:eureka-server<br><strong>POM文件</strong></p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><p>依赖security的原因是，这个springcloud的版本对安全要求更严格，当然也有方法来阻止这种安全检查。<br><strong>application.yml</strong></p>
<pre><code>server:
  port: 7001
eureka:
  instance:
    hostname: localhost
  client:
    register-with-eureka: false
    fetch-registry: false
    service-url:
      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
spring:
  security:
    user:
      name: root
      password: root</code></pre><p>以上配置文件标识注册中心端口为7001，注册服务地址为defaultZone的值地址，然后是配置一下security的用户名密码，这个用户名密码需要在eureka-client连接时写上。<br>此处需要添加对security的配置</p>
<pre><code>@EnableWebSecurity
public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter &#123;
    @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        // Configure HttpSecurity as needed (e.g. enable http basic).
        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER);
        http.csrf().disable();
        //注意：为了可以使用 http://$&#123;user&#125;:$&#123;password&#125;@$&#123;host&#125;:$&#123;port&#125;/eureka/ 这种方式登录,所以必须是httpBasic,
        // 如果是form方式,不能使用url格式登录
        http.authorizeRequests().anyRequest().authenticated().and().httpBasic();
    &#125;
&#125;</code></pre><p>然后就是启动类了,只需要@EnableEurekaServer注解</p>
<pre><code>@EnableEurekaServer
@SpringBootApplication
public class EurekaServerApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(EurekaServerApplication.class,args);
    &#125;
&#125;</code></pre><p>最后访问localhost:7001即可进入页面，如果有密码，则输入security配置的即可。</p>
<h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><p>接下来讲就是服务提供者，就是一般的访问数据库的，我只列出Controller的简单代码。</p>
<pre><code>@RestController
public class UserController &#123;

    @Autowired
    private UserService userService;

    @ResponseBody
    @PostMapping(&quot;/user/add&quot;)
    public boolean add(@RequestBody User user)&#123;
        return userService.add(user);
    &#125;

    @ResponseBody
    @GetMapping(&quot;/user/get/&#123;id&#125;&quot;)
    public User get(@PathVariable(&quot;id&quot;) Long id)&#123;
        return userService.get(id);
    &#125;

    @ResponseBody
    @GetMapping(&quot;/user/list&quot;)
    public List&lt;User&gt; list()&#123;
        return userService.list();
    &#125;
&#125;</code></pre><p>接下来，重要的还是配置文件</p>
<pre><code>server:
  port: 9001
eureka:
  instance:
    instance-id: springcloud8001
    prefer-ip-address: true
  client:
    service-url:
      defaultZone: http://root:root@localhost:7001/eureka/
spring:
  application:
    name: SPRING-PROD
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型
    driver-class-name: com.mysql.jdbc.Driver              # mysql驱动包
    url: jdbc:mysql://localhost:3306/cloud1?serverTimezone=UTC&amp;characterEncoding=utf-8              # 数据库名称
    username: root
    password: root
    dbcp2:
      min-idle: 5                                           # 数据库连接池的最小维持连接数
      initial-size: 5                                       # 初始化连接数
      max-total: 5                                          # 最大连接数
      max-wait-millis: 200                                  # 等待连接获取的最大超时时间
mybatis:
  type-aliases-package: com.fsats.user.entity    # 所有Entity别名类所在包
  mapper-locations:
    - classpath:mapper/**/*.xml                       # mapper映射文件
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</code></pre><p>以上配置表示,服务提供者的端口,eureka.instance.instance-id表示注册在服务上的显示的名称。而spring.application.name就比较重要了，是当前服务的应用名称,多个相同的服务提供者负载均衡，instance-id可以不同，但这个值一定要一样，他表示一个独立的微服务应用。而且feign使用也是需要这个应用名称的。<br>剩下的就是mybatis和连接数据库了。<br>这个service提供者，我使用了新模块，并在新模块cloudservice里再新建的user-service模块,因此把依赖放到父模块cloudservice里。</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fsats&lt;/groupId&gt;
        &lt;artifactId&gt;user-api&lt;/artifactId&gt;
        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;2.0.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><p>启动类的话只需要加上@EnableEurekaClient注解即可。</p>
<p>服务提供者的主要内容就是，作为服务提供外部访问，然后把自己注册到服务注册中心去。</p>
<p>在上面依赖里依赖了user-api，它是feign客户端，是服务消费者与服务提供者沟通的桥梁。<br>如果桥梁呢,首先这个api定义后，服务提供者和服务消费者都可以依赖他，提供者可以获取实体类，也可以在自己模块定义实体类。<br>先看一下UserFeignClient类</p>
<pre><code>@FeignClient(value = &quot;SPRING-PROD&quot;)
public interface UserFeignClient&#123;

    @PostMapping(&quot;/user/add&quot;)
    boolean add(@RequestBody User user);

    @GetMapping(&quot;/user/&#123;id&#125;&quot;)
    User get(@PathVariable(&quot;id&quot;) Long id);

    @GetMapping(&quot;/user/list&quot;)
    List&lt;User&gt; list();

&#125;</code></pre><p>它就表示一个feign客户端,主要调用SPRING-PROD应用里的请求。<br>那么，逻辑明显了，服务消费者通过自己的请求，然后注入这个UserFeignClient类，便可以操作了。这个类的方法因为已经标识了应用名称，所以他会以webservice的方式和方法上定义的请求路径去请求这个地址。并把结果给服务消费者。<br>那么很显然，服务消费者是一定需要这个类的包的，但是如何知道这个feign，那就是通过另一个注解@EnableFeignClients扫描，在服务提供者类里扫描包含@FeignClient注解的方法,因为已经引入api这个包了，所以一定是扫描的上的，并且如果扫描上，直接被注入容器中。</p>
<h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><p>服务消费者也属于服务，但可以不注册。<br>看一下yml</p>
<pre><code>server:
  port: 8001

eureka:
  client:
    service-url:
      defaultZone: http://root:root@localhost:7001/eureka
    register-with-eureka: false

info:
  app.name: springcloud-test-8001
  company.name: www.fsats.com
  build.artifactId: $project.artifactId$
  build.version: $project.version$</code></pre><p>register-with-eureka表示，不在注册中心注册自己，虽然这里已经定义了路径，但是是没有注册的。info后面的可以去掉，这个是服务的相关定义信息。</p>
<p><strong>POM文件</strong></p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fsats&lt;/groupId&gt;
    &lt;artifactId&gt;user-api&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>接下来需要在启动类中标注@EnableFeignClients注解</p>
<pre><code>@EnableFeignClients(basePackages = &#123;&quot;com.fsats.user&quot;&#125;)
@EnableEurekaClient
@SpringBootApplication
public class ConsumerApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(ConsumerApplication.class,args);
    &#125;
&#125;</code></pre><p>其中，basePackage表示扫描的注解基础路径,此处填写api模块的包名。</p>
<pre><code>@RestController
public class UserController &#123;

    //@Autowired
    private IUserClient iUserClient;

    @PostMapping(&quot;/consumer/user/add&quot;)
    public boolean add(User user)&#123;
        return this.iUserClient.add(user);
    &#125;

    @GetMapping(&quot;/consumer/user/get/&#123;id&#125;&quot;)
    public User get(@PathVariable(&quot;id&quot;) Long id)&#123;
        return this.iUserClient.get(id);
    &#125;

    @GetMapping(&quot;/consumer/user/list&quot;)
    public List&lt;User&gt; list(User user)&#123;
        return this.iUserClient.list();
    &#125;
&#125;</code></pre><p>在Controller中，既然启动类上已经扫描feignClient了，这里也不需要@AutoWired注解也是可以请求的。<br>另外，这个PostMapping在postman使用里测试，不能在params里写参数并使用post提交，必须在Body里，选择raw，然后填写json格式数据才能正确提交。因为feignClient里定义了@RequestBody注解。</p>
<p>包结构如下:</p>
<p><img src="https://i.loli.net/2019/11/01/GkJfy9WDsbRLmZC.png" alt="TIM截图20191101131246.png"></p>
<p>项目下载地址:<a target="_blank" rel="noopener" href="https://nas.tsaving.cn/file/download/71">https://nas.tsaving.cn/file/download/71</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/16/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/42/">42</a><a class="extend next" rel="next" href="/page/18/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020-2021
        陈光奇
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      
      <li>
        <a href="http://www.beian.miit.gov.cn/" target="_black">京ICP备17065668号-3</a>
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer.jpg" alt="Notes"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.png">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/share.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/js/ayer.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>